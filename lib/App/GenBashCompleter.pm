package App::GenBashCompleter;

# DATE
# VERSION

use 5.010001;
use strict;
use warnings;
#use Log::Any '$log';

use Data::Dump qw(dump);

our %SPEC;

sub _gen_gl {
    my $spec = shift;

    my @res;

    for (keys %$spec) {
        $spec->{$_} = sub{};
    }

    push @res, "use Getopt::Long::Complete qw(GetOptionsWithCompletion);\n";
    push @res, "my \@spec = ", dump(%$spec), ";\n";
    push @res, "GetOptionsWithCompletion(sub{}, \@spec);\n";
    join "", @res;
}

$SPEC{gen_bash_completer} = {
    v => 1.1,
    args => {
        path => {
            summary => 'Path to program/script to generate completion for',
            description => <<'_',

You can specify `-` to mean stdin.

_
            schema => 'str*',
            req => 1,
            pos => 0,
        },
    },
    result => {
        summary => 'Will return bash completer script, or undef',
        schema => 'buf*',
    },
};
sub gen_bash_completer {
    my %args = @_;

    my $path = $args{path};
    my $content;
    {
        local $/;
        if ($path eq '-') {
            $content = <STDIN>;
        } else {
            open my($fh), "<", $path
                or return [500, "Can't open file '$path': $!"];
            $content = <$fh>;
        }
    }

    my $reason;
    my $shebang;
    my $completer;
  DETECT:
    {
        if ($content !~ /\A(#!.+)/) {
            $reason = 'Not a script (no shebang line)';
            last DETECT;
        }
        $shebang = $1;
        if ($shebang !~ /.+\bperl\b/) {
            $reason = 'Shebang line does not indicate this is a Perl script';
            last DETECT;
        }
        if ($content =~ /(use|require)\s+
                         (Getopt::Long::Complete|
                             Perinci::CmdLine(::Any|::Lite)?)\b/sx) {
            return [304, "Script using $1 can complete itself"];
        }
        if ($content =~ /(use|require)\s+(Getopt::Long)\b/sx) {
            require Capture::Tiny;
            require UUID::Random;
            my $tag = UUID::Random::generate();
            my ($stdout, $stderr, $exit) = Capture::Tiny::capture(
                sub {
                    system $^X,
                        "-MGetopt::Long::Patch::DumpAndExit=-tag,$tag",
                        $path;
                },
            );
            if ($stdout =~ /^# BEGIN DUMP $tag\s+(.*)^# END DUMP $tag/ms) {
                my $spec = eval $1;
                if ($@) {
                    $reason = "Detected as Perl script using Getopt::Long, ".
                        "but error in eval-ing captured option spec: $@, ".
                            "raw captured option spec: <<<$1>>>";
                     last DETECT;
                }
                if (ref($spec) ne 'HASH') {
                    $reason = "Detected as Perl script using Getopt::Long, ".
                        "but got a non-hash option spec?";
                }
                $completer = _gen_gl($spec);
                last DETECT;
            } else {
                $reason = "Detected as Perl script using Getopt::Long, ".
                    "but can't capture option spec";
                last DETECT;
            }
        }
        $reason = "No completion hints available";
    } # DETECT

    if ($completer) {
        my @res = ($shebang, "\n");

        push @res, "# generated by $0 on " . localtime . "\n";

        push @res, "# FRAGMENT id=bash-completion-prog-hints completer=1";
        if ($path ne '-') {
            my $progname = $path; $progname =~ s!.+[/\\]!!;
            push @res, " for=$progname";
        }
        push @res, "\n";

        push @res, $completer;
        $completer = join "", @res;
    }

    return [200, "OK", $completer, {'func.reason' => $reason}];
}

1;
# ABSTRACT: Backend for gen-bash-completer
